#!/usr/bin/env bash

######
# Shwain is a Mark Twain for bash (i.e. logger).
# It aims to be a partial functional clone of https://github.com/nir0s/wryte.
#
# Usage:
#   shwain info message key1=value1 key2=value2 --json
#   shwain event "Killing process" pid="$$"
#   shwain error WOOT! errorlevel=$errorlevel --simple
######

###
# Color mapping for severity levels.
# http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html
###


declare readonly USAGE="Usage: $(basename "$0") [OPTIONS] LEVEL MESSAGE [OBJECTS]...

Options:
  -j, --json         Use the JSON logger formatter instead of the console one
  -n, --name TEXT    Change the default logger's name
  --no-color         Disable coloring in console formatter
  --simple           Log only message to the console
  --enrich           Enrich with additional metadata like hostname, pid, etc..
  -h, --help         Show this message and exit.
"

declare -A COLOR_MAPPING=(
  ["DEBUG"]="0;36"    # CYAN
  ["INFO"]="0;32"     # GREEN
  ["WARNING"]="1;33"  # YELLOW
  ["WARN"]="1;33"     # YELLOW
  ["ERROR"]="0;31"    # RED
  ["CRITICAL"]="1;31" # BRIGHT RED
  ["EVENT"]="1;32"    # BRIGHT GREEN
)

declare -A LEVEL_MAPPING=(
  ["DEBUG"]=1
  ["INFO"]=2
  ["WARNING"]=3
  ["WARN"]=3
  ["ERROR"]=4
  ["CRITICAL"]=5
  ["EVENT"]=6
)

declare readonly EFFECTIVE_LOG_LEVEL=${EFFECTIVE_LOG_LEVEL:-${LEVEL_MAPPING[DEBUG]}}


function log.info() {
  local readonly message="$1"
  shift
  local readonly kvs=("$@")

  _log "INFO" $message kvs
}

function log.debug() {
  local readonly message="$1"
  shift
  local readonly kvs=("$@")

  _log "DEBUG" $message kvs
}

function log.warn() {
  local readonly message="$1"
  shift
  local readonly kvs=("$@")

  _log "WARNING" $message kvs
}

function log.warning() {
  local readonly message="$1"
  shift
  local readonly kvs=("$@")

  _log "WARNING" $message kvs
}

function log.error() {
  local readonly message="$1"
  shift
  local readonly kvs=("$@")

  _log "ERROR" $message kvs
}

function log.error() {
  local readonly message="$1"
  shift
  local readonly kvs=("$@")

  _log "CRITICAL" $message kvs
}

function log.event() {
  local readonly message="$1"
  shift
  local readonly kvs=("$@")

  _log "EVENT" $message kvs
}

function _log() {
  local level="$1"
  local readonly message="$2"
  local -n kv="$3"
  local readonly json="${4:-$SHWAIN_JSON}"

  # If name not provided, default to env var. If env var not provided, default to "SHWAIN"
  local name="${5:-$SHWAIN_NAME}"; name="${name:-SHWAIN}"
  local readonly color="${6:-$SHWAIN_COLOR}"
  local readonly simple="${7:-$SHWAIN_SIMPLE}"
  local readonly enrich="${8:-$SHWAIN_ENRICH}"

  local log='';

  local readonly pid="$$"
  local readonly hostname=$(hostname)
  local readonly timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
  local type="log"

  # Assert log level
  (( ${LEVEL_MAPPING[${level^^}]} >= $EFFECTIVE_LOG_LEVEL )) || return 0

  # We want the type field to be event only if the level is event.
  if [ "$level" == "EVENT" ] || [ "$level" == "event" ]; then type="event"; fi

  local expanded_kv='  '
  # Enrich kvs
  if [ ! -z $enrich ]; then
    kv+=("pid=$pid" "hostname=$hostname" "type=$type")
  fi

  for ((i = 0; i < ${#kv[@]}; i++))
  do
    expanded_kv="$expanded_kv"$'\n'"  ${kv[$i]}"
  done

  if [ ! -z "$json" ]; then
    kv+=("timestamp=$timestamp" "name=$name" "level=$level")
    # Holy shit this is disgusting. Also, can't pass json as a field.
    # It's still parsable by jq but still.. oi.
    # TODO: You know.. make this.. code-not-shit.
    printf '{\n'
    # For each key value pair
    for ((i = 0; i < ${#kv[@]}; i++))
    do
      # split it by `=`
      IFS='=' read -ra "pair" <<< "${kv[$i]}"
      printf "  \"${pair[0]}\": \"${pair[1]}\",\n"
      expanded_message="$expanded_message"$'\n'"  $i"
    done

    printf "  \"message\": \"${message}\"\n"
    printf '}'
  else
    if [ -z "$simple" ]; then
      if [ -z "$color" ]; then
        level="\e[${COLOR_MAPPING[${level^^}]}m${level^^}\e[0m"
      fi
      log="$timestamp - $name - $level - ${message} ${expanded_kv}"
    else
      log="$message"
    fi
  fi

  echo -e "$log"
}

function _main() {
  getopt --test > /dev/null
  if [[ $? -ne 4 ]]; then
    echo "I’m sorry, `getopt --test` failed in this environment."
    exit 1
  fi

  OPTIONS=hn:je
  LONGOPTIONS=simple,name:,json,no-color,help,no-enrich

  # Temporarily store output to be able to check for errors
  # e.g. use “--options” parameter by name to activate quoting/enhanced mode
  # pass arguments only via -- "$@" to separate them correctly
  PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@")

  if [[ $? -ne 0 ]]; then
      # e.g. $? == 1
      #  then getopt has complained about wrong arguments to stdout
      exit 2
  fi

  # Read getopt’s output this way to handle the quoting right:
  eval set -- "$PARSED"

  while true; do
    case "$1" in
      -j|--json)
        json=y
        shift
        ;;
      -n|--name)
        name="$2"
        shift
        ;;
      --no-color)
        color=y
        shift
        ;;
      --simple)
        simple=y
        shift
        ;;
      -e|--enrich)
        enrich=n
        shift
        ;;
      -h|--help)
        echo "$USAGE"
        exit 0
        ;;
      --)
        shift
        break
        ;;
    esac
  done

  if [ $# -le 1 ]
    then
      echo "$USAGE" >&2

      echo "You must at least provide two arguments: i.e shwain LEVEL MESSAGE"
      exit 1
  fi

  # Assign level and message from left-over arguments and then shift
  # so that `kvs` contains only the key value pairs.
  local readonly level="$1"
  local readonly message="$2"
  shift; shift
  local readonly kvs=("$@")

  _log "$level" "$message" kvs "$json" "$name" "$color" "$simple" "$enrich"
}

# Only run main if not sourced.
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  _main "$@"
fi
